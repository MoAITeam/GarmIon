\chapter{Front End}\label{ch:frontend}

In questa sezione l'intento è quello di esporre tutte le tecnologie più importanti che sono state necessarie per sviluppare il front end della nostra applicazione. In particolare il front end si occupa di definire una interfaccia utente intuitiva attraverso la quale l'utente può interagire per inviare dati al server e assue la responsabilità di elaborare e gestire tali dati in ingresso affinchè siano conformi a quelli richiesti dal back end.

\section{Ionic}

Ionic è un framework open source creato allo scopo di realizzare app cross platform native e web app semplice, veloce ed efficiente. Rilasciato nel corso del 2013 da Drifty co. , inizialmente si basava solamente su Angular JS; tuttavia lo sviluppo è proseguito andando ad inglobare i nuovi framework per UI React, Angular e Vue.Si tratta di un modulo npm e quindi necessita di Node.js per funzionare.
In particolare questa tecnologia provvede gli strumenti per sviluppare web app e app mobile ibride basate su tecniche e pratiche moderne, integrando tecnologie web come CSS, SCSS  e HTML e per rilasciarle sul mercato mobile attraverso Capacitor o Cordova, che si occupano della conversione dell'app in modo che sia compatibile con il device in uso.
In particolare nel corso dello sviluppo abbiamo utilizzato i seguenti componenti Ionic per la realizzazione del nostro applicativo:
\begin{itemize}
\item ion-slides: è un container multisezione, dove si può  scorrere ogni sezione per visualizzare delle ion-slide. L'abbiamo utilizzata in "garment-detail" al fine di potere proporre una moltitudine di abbinamenti per il capo scelto dall'utente e in modo che quest'ultimo possa scorrere tra esse e scegliere quella che è più di suo gusto.
\item ion-content: provvede un area per i contenuti ed offre diversi metodi per controllare lo scrolling. Viene utilizzato una singola volta in tutti i nostri componenti al fine di poter definirne i contenuti.
\item ion-header: è il componente che definisce la parte estrema superiore dell'app. Permette la definizione al suo interno di una toolbar e la contestualizzazione della tab o pagina in cui siamo attraverso la possibilità di aggiungergli un testo.
\item ion-img: è il tag sostitutivo al quasi omonimo tag <img> di HTML. In realtà  per quanto lo scopo possa essere similare, le caratteristiche e le funzioni della versione Ionic sono nettamente superiori. In particolare nel nostro caso, dovendo visualizzare potenzialmente molte foto (chiaramente va in base alla dimensione dell'armadio dell'utente), questo componente ci è estremamente utile in quanto implementa un meccanismo di lazy-load che permette di caricare le immagini solo quando queste ultime sono effettivamente visibili. In questo modo ci permette di realizzare un meccanismo di paging in automatico, il quale ci permette di evitare fastidiosi rallentamenti e cali di prestazioni per il caricamento di troppe immagini contemporaneamente. Parlando di tecnica, ion-img utilizza "IntersectionObserver" per questo scopo: quest'ultima è una API che viene utilizzata per capire la visibilità e la posizione degli elementi del DOM relativi alla viewport, posizione che viene "spedita" in maniera asincrona agli elementi che fanno uso di questa funzione. 
\item ion-select: implementa un form grazie al quale l'utente può selezionare una o più opzioni, simile al <select> nativo. Quando l'utilizzatore preme sul form, viene visualizzato un dialog attraverso il quale può effettuare la sua scelta in maniera intuitiva premendo su uno degli elementi della lista, che vengono tecnicamente definiti da dei <ion-select-option>.
\item ion-card:  Le cards sono una parte standard dell'interfaccia utente che funge da punto di ingresso per informazioni più dettagliate. Una card può essere un singolo componente, ma spesso è composta da intestazione, titolo, sottotitolo e contenuto. Grazie a questo componente abbiamo potuto dare alla nostra app un aspetto grafico decisamente più ordinato e intuitivo, in quanto ci ha permesso di raggruppare molti elementi del nostro progetto in delle box predefinite.
\item ion-icon: permette di definire una icona che viene recuperata da un pacchetto di icone sviluppate appositamente per "Ionic".
\item ion-alert: Un alert è una finestra di dialogo che presenta agli utenti informazioni o raccoglie informazioni dall'utente. Viene visualizzato un avviso personalizzabile sopra il contenuto dell'app e deve essere eliminato manualmente dall'utente prima che possa riprendere l'interazione con l'app. Può anche avere opzionalmente un header, subHeader e message.Lo abbiamo utilizzato principalmente per dare consigli di uso all'utente o avvisarlo di possibili dati che potrebbe non aver compilato.
\item ion-button:  forniscono un elemento cliccabile, che può essere utilizzato nei moduli o ovunque si necessiti di funzionalità di pulsanti semplici e standard. Possono visualizzare testo, icone o entrambi. I pulsanti possono essere stilizzati con diversi attributi per apparire in un modo specifico al fine di rispettare i diversi design delle app. L'utilizzo dei bottoni ricalca quello di un trigger: infatti attraverso l'attributo (ionChange) si può collegare una funzione all'evento di click del bottone stesso.
\item ion-fab-button: I pulsanti di azione mobili (FAB) rappresentano l'azione principale in un'applicazione. Per default, hanno una forma circolare. Quando viene premuto, il pulsante può scatenare una o diverse funzioni, esattamente come gli "ion-button". Come suggerisce il nome, i FAB generalmente fluttuano sul contenuto in una posizione fissa. Ciò si ottiene esclusivamente utilizzando un componente <ion-fab> che fa da contenitore al bottone e che gli permette di fissarli al contenuto della pagina. Se il pulsante FAB non è avvolto con  <ion-fab> , scorrerà con il contenuto. I pulsanti FAB hanno una dimensione predefinita, comunque configurabile, e possono accettare diversi colori.
\item ion-grid: è un potente sistema flexbox mobile-first per la creazione di layout personalizzati. È composto da tre unità: una griglia, riga/e e colonna/e, rispettivamente realizzate tecnicamente dagli elementi <ion-grid>, <ion-row> e <ion-col>. Le colonne si espanderanno per riempire la riga e verranno ridimensionate per adattarsi a colonne aggiuntive. Si basa su un layout a 12 colonne con diversi punti di interruzione in base alle dimensioni dello schermo. Il numero di colonne può essere personalizzato tramite CSS.
Questo sistema realizza un modo pratico e veloce per fornire all'applicativo un layout ordinato e pulito, nonchè avere una disposizione simmetrica di tutti gli elementi che compongono la pagina.
\item ion-tabs: sono un componente di navigazione di primo livello per implementare una navigazione basata su schede. Il componente non ha stile e funziona come outlet del router per gestire la navigazione. Non fornisce alcun feedback sull'interfaccia utente o meccanismo per passare da una scheda all'altra. Per fare ciò, è necessario definire un <ion-tab-bar> che dovrebbe essere fornito come figlio diretto di <ion-tabs>. 
Entrambi ion-tabs e ion-tab-bar possono essere utilizzati come elementi autonomi. Non dipendono l'uno dall'altro per funzionare, ma di solito vengono utilizzati insieme per implementare una navigazione basata su schede che si comporta come un'app nativa.
Gli elementi che costituiscono un <ion-tabs> sono gli <ion-tab>, componente dichiarativo per un NavController e che permette di definire una tab in modo da separare visualmente sezioni diverse dell'app. 
\item ion-loading: è un overlay che può essere utilizzato per indicare l'attività durante il blocco dell'interazione dell'utente. L'indicatore di caricamento viene visualizzato sopra il contenuto dell'app e può essere ignorato dall'app per far riprendere l'interazione dell'utente. Si rivela molto utile in quelle situazioni in cui è necessaria una elaborazione dati che impiega diverso tempo e quindi garantisce un alto livello di usabilità, in quanto fornisce all'utente un feedback chiaro del caricamento in corso.
\end{itemize}


\section{Capacitor}

Capacitor è un runtime opensource per creare Native Web Applications, vale a dire per realizzare applicazioni mobile native semplicemente utilizzando Javascript, HTML e CSS.
 Capacitor rappresenta l’evoluzione delle app ibride permettendoti di creare applicazioni in un’ottica web first senza pregiudicare la possibilità di sfruttare la tecnologia nativa del mondo mobile attraverso specifiche API.
Capacitor è il successore di fatto di tecnologie come Apache Cordova e Adobe PhoneGap, è ispirato da altri tool come React Native, è completamente integrato di default in Ionic App e permette la retrocompatibilità con i plugin di Cordova per una maggiore aderenza alle varie esigenze di sviluppo.  Seppur condividendo i vantaggi multipiattaforma con Cordova, Capacitor possiede però un approccio più moderno allo sviluppo di app, e sfrutta le più recenti API web. In particolare, come si può intuire è stato integrato con Ionic al fine della realizzazione di questo progetto.

Capacitor fornisce un set di API coerente e incentrato sul Web che consente a un'app di rimanere il più vicino possibile agli standard Web, accedendo al contempo a ricche funzionalità native del dispositivo su piattaforme che le supportano. Infatti può sfruttare numerose API per accedere alle strumentazioni del device in uso come:
\begin{itemize}
\item Camera: utilizzata per catturare foto e video, noi la abbiamo sfruttata per acquisire le immagini degli indumenti.
\item File System: per leggere e scrivere file sul disco del dispositivo mobile.
\item Geolocation: per utilizzare le informazioni del GPS 
\item Accelerometer: per utilizzare le informazioni dell’accelerometro.
\item Notifications: per gestire le notifiche push.
\item Network: per gestire le app e le informazioni online ed offline.
\item Haptics: per gestire gli input fisici nei moderni dispositivi.
\end{itemize}

Il nostro caso d'uso ci ha permesso di utilizzare solo le prime due funzionalità tra quelle proposte qui sopra, in quanto l'applicativo si propone di catturare le foto del'indumento e, una volta processate, scriverle in archiviazione locale in modo da poterle recuperare anche in una sessione successiva e quindi garantendo una persistenza dei dati necessaria. In particolare abbiamo fatto uso dei moduli Camera e Storage di Capacitor per raggiungere lo scopo prefissato sopra: tramite i metodi esposti da essi è stato possibile utilizzare la fotocamera del device in uso per catturare l'immagine e successivamente salvarla in locale in formato base64 grazie alle funzioni di Storage.

Inoltre Capacitor può essere integrato con strumenti come React, Angular (in uso), Svelte, Vue e Stencil sia per la realizzazione da zero di applicativi web e nativi sia per convertire una web app già realizzata in una app ibrida pronta per diventare nativa.

\section{Angular}

Occuparsi del front end di una applicazione senza integrare un framework dedicato potrebbe essere molto più complicato del previsto, in quanto dover gestire il tutto basandosi solo sugli strumenti che HTML, CSS  e JavaScript mettono a disposizione non sempre permettono di raggiungere un livello di profondità di sviluppo, mantenendo allo stesso tempo semplicità di comprensione e ordine a livello di organizzazione e struttura.

Per queste ragioni ci siamo affidati al framework open source Angular sviluppato da Google, che da anni la fa ormai da padrone all'interno del panorama dello sviluppo di applicativi web grazie alla velocità con cui si riesce ad apprendere e alle innumerevoli possibilità che offre per semplificare la scrittura di codice e markup.

In quanto è stato pensata come tecnologia mobile first, se usato in combinazione con il toolkit opensource Bootstrap o come nel nostro caso con Ionic riesce a far diventare le applicazioni responsive, ovvero il loro design si adatta in funzione delle dimensioni del dispositivo in uso.

Parlando di tecnicismi, al posto di JavaScript per quanto riguarda la gestione del lato scripting dell'applicativo, viene usato TypeScript, linguaggio di programmazione opensource sviluppato da Microsoft che rimane comunque retrocompatibile in quanto ogni programma scritto in JavaScript funzionerà anche in TypeScript.

Le applicazioni sviluppate in Angular vengono eseguite interamente dal web browser dopo essere state scaricate dal web server (elaborazione lato client). Questo comporta il risparmio di dover spedire indietro la pagina web al web-server ogni volta che c'è una richiesta di azione da parte dell'utente. Il codice generato da Angular gira su tutti i principali web browser moderni quali ad esempio Chrome, Microsoft Edge, Opera, Firefox, Safari ed altri.

Al fine di definire in maniera più approfondita l'uso che abbiamo fatto di questo strumento al fine di realizzare questo applicativo, è necessario entrare nel dettaglio degli strumenti che abbiamo utilizzato. In particolare è stato di grande aiuto l'utilizzo di componenti, grazie ai quali abbiamo potuto considerare degli elementi della app, quindi scritto in HTML, come se fossero oggetti, rendendo possibile una maggior facilità a livello di gestione della dinamica e del passaggio di dati tra componenti padri e figli. I servizi, invece, sono stati fondamentali a mantenere informazioni che dovevano essere trasmesse tra componenti, mentre le direttive sono state utilizzate per creare o distruggere a runtime gli elementi nel DOM a seconda dei comportamenti desiderati.
\subsection{Componente} 

Un componente è l’elemento principale di un’applicazione Angular, in particolare contiene la logica di interazione dati e utente che definisce l’aspetto ed il comportamento della vista.
I componenti Angular sono semplici classi Javascript, definiti tramite il decoratore @Component che fornisce al componente la vista per visualizzare i metadati della classe. I componenti forniscono dati alla vista utilizzando l’associazione di dati per farlo, il cosiddetto data binding. In questo modo il componente può anche sapere quando la vista viene modificata e soprattutto permette al componente stesso di passare dati alla vista in modo completamente dinamico. Le applicazioni Angular possono avere N componenti, nel quale ognuno viene dedicato a gestire una singola porzione dell’interfaccia utente, lavorando insieme per fornire la UI dell’applicazione.

Inoltre un componente è una entità personalizzabile e configurabile che può a sua volta essere inserito all'interno di altri componenti. È quindi possibile andare a definire una gerarchia dove le entità padre (quelle che contengono) possono condividere con le entità figlie delle informazioni, e viceversa e figlie possono notificare i padri se queste informazioni o altre proprietà sono cambiate.Nel progetto globale si andrà quindi ad instaurare una gerarchia ad albero che vedrà come radice un elemento base che di default è nominato AppComponent che presenta un selettore <app-root> che viene aggiunto ad index.html.

Trattato il decoratore @Component che rende una classe un componente è necessario analizzare le principali propriet che vanno a descrivere il componente:
\begin{itemize}
\item Selector: specifica un tag tramite il quale la nostra vista che rappresenta il componente viene posizionata nel progetto Angular.
\item providers: sono i servizi che verranno utilizzati dal componente. I servizi forniscono dati al componente o ad altri servizi.
\item directives: ovvero le direttive che utilizza il componente.
\item styles: gli stili CSS o il foglio di stile di cui ha bisogno il componente. Possiamo usare un foglio di stile esterno (usando styleUrls) o stili incorporati (utilizzando styles), detti stili sono specifici del componente.
\item template: modello HTML che definisce la nostra vista. Indica ad Angular come eseguire il rendering della vista del componente. I template possono essere in linea (con template) oppure si può utlizzare un file esterno (templateUrl). Un componente può avere solo un modello.
\end{itemize}
 
Dato che comunque il componente rimane un oggetto e come tale è provvisto di un costruttore, è soggetto alle meccaniche di lifecycle degli oggetti che determinano la creazione,la modifica, la cancellazione di un oggetto. La definizione di queste meccaniche ci permette di avere un maggior controllo sul nostro componente grazie ai lifecycle hooks, ovvero metodi che verranno opportunatamente invocati da Angular in corrispondenza della fase in cui si trova il componente durante il suo ciclo di vita. In totale Angular mette a disposizione 8 hooks che rispecchiano un momento preciso della vita del componente:
\begin{itemize}
\item ngOnInit: invocato in fase di inizializzazione, dopo che è stato eseguito il costruttore.
\item ngOnChanges: invocato quando viene rilevata una modifica delle proprietà a cui viene applicato il decoratore @Input(), funziona solo nel caso in cui le proprietà di Input sono di un tipo semplice (come string, number, ecc..) mentre invece il cambiamento di un oggetto passato per riferimento viene rilevato solo se cambia il riferimento stesso.
\item ngDoCheck: viene sempre invocato quando viene effettuata una modifica a un componente. A differenza di ngOnChanges(), questo metodo viene invocato ogni volta.
\item ngAfterContentInit: viene chiamato dopo che è stata completata l'inizializzazione degli elementi passati al componente dall'esterno a cui si fa riferimento col nome Content Children.
\item ngAfterContentChecked: viene invocato dopo che il meccanismo di Change Detection di Angular ha controllato tutti i suoi Content Children.
\item ngAfterViewInit: invocato immediatamente dopo che Angular ha completato l'inizializzazione della view di un componente e dei suoi View Children. Il metodo che lo precede è ngAfterContentChecked().
\item ngAfterViewChecked: invocato in questo caso la prima volta dopo il metodo ngAfterViewInit(). Successivamente viene preceduto dal Lifecycle hook ngAfterContentChecked() e viene eseguito non appena Angular ha controllato la view del componente e dei suoi View Children.
\item ngOnDestroy: eseguito prima di distruggere il componente.
\end{itemize}


\subsection{Servizi}

Nel caso in cui si vogliano far comunicare due componenti (sia unilateralmente che bilateralmente) che non siano parent e child, allora la soluzione che abbiamo utilizzato per sopperire a questo scopo sono stati proprio i servizi. Oltre a questo ambito è possibile utilizzare i servizi anche per la gestione della logica di business dell'applicazione.

Un servizio è solitamente rappresentato da una classe indipendente dalla View che viene definita per svolgere un compito ben preciso ed effettuare delle operazioni strettamente correlate tenendo in mente il principio di singola responsabilità. È ovviamente possibile definire più servizi all'interno di un'applicazione, ognuno dei quali si occuperà di portare a termine un determinato incarico. Chiaramente una volta creati i servizi potranno interagire con gli altri componenti: è necessario infatti iniettarli all'interno di uno o più componenti tramite un meccanismo di Dependency Injection.
Oltre a rendere più facile la comunicazione tra componenti i servizi sono anche molto più facili da testare e sono facilmente riutilizzabili.

\subsection{Direttive}

Oltre ai componenti che sono una particolare direttiva caratterizzata dalla presenza di un template, nel nostro progetto abbiamo usato in particolare le direttive strutturali che permettono di modificare la struttura del DOM, permettendo così di aggiungere o cancellare gli elementi in base a precise richieste.

Le più importanti sono, le direttive:
\begin{itemize}
\item NgIf: funziona esattamente come un if logico. Se il risultato della proposizione da testare è vero allora l'elemento viene renderizzato, altrimenti questo viene rimosso temporaneamente dal DOM. Ovviamente se l'elemento a cui viene applicata la direttiva dovess contenere altri componenti e il risultato dell'if fosse falso, allora anche essi non verrebbero visualizzati
\item ngForOf: allo stesso modo, questa direttiva ricalca la versione logica di un for. Molto utile per renderizzare una serie di componenti o elementi a partire da un vettore di informazioni, un'esempio nella applicazione che stiamo trattando possiamo trovarlo nella galleria principale che visualizza l'armadio virtuale. Qui infatti viene iterato tutto il vettore che contiene le immagini e i metadati corrispondenti agli indumenti e per ognuno viene creato e mostrato il componente che si occupa di visualizzare il vestito.
\end{itemize}

\subsection{TypeScript}

Typescript è un linguaggio di programmazione sviluppato da Microsoft ma comunque open-source, che riprende completamente la sintassi di javascript, estendola. Infatti può essere definito come superset di JavaScript. La prima differenza fondamentale tra i due è che JavaScript è un linguaggio di scripting lato client, mentre TypeScript è un linguaggio compilato orientato agli oggetti. Inoltre quest'ultimo permette un controllo di tipo statico, che può comunque essere reso dinamico.

Questa caratteristica che permette di andare a definire il tipo a variabili e funzioni rende molto più facile il debugging e la lettura stessa del codice. Nel dettaglio TypeScript ha tipi di dati come String, Number, Boolean, Null, Array, Enum, Tuple e Generics. 

Un altro vantaggio è che consente di creare degli oggetti che si basano su delle classi, un po' come accade in altri linguaggi di programazzione orientati agli oggetti come C++ e Java, possibilità che invece non è ammessa in JavaScript dove l'oggetto sarebbe stato in maniere anti intuitiva attraverso una funzione. Basandosi sulle classi, TypeScript supporta anche concetti come ereditarità, incapsulamento e polimorfismo, recuperati dal background di altri linguaggi orientati agli oggetti e che gli permettono di estendere le possibilità offerte al programmatore.

Tuttavia, al di là delle differenze che intercorrono tra JavaScript e TypeScript, questi due linguaggi restano comunque molto simili. Difatti tutte le funzionalità di JavaScript sono disponibili in TypeScript, in quanto quest'ultimo è un superset del primo.

Abbiamo fatto uso di TypeScript per lo sviluppo di questa applicazione in quanto è un linguaggio richiesto per l'uso di Angular.





